<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Driving Safety Monitor</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #eee; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        h1 { text-align: center; margin-bottom: 20px; color: #00d4ff; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .card { background: #16213e; border-radius: 10px; padding: 20px; }
        .stat-card { text-align: center; }
        .stat-value { font-size: 2.5em; font-weight: bold; color: #00d4ff; }
        .stat-label { color: #888; margin-top: 5px; }
        .stat-card.warning .stat-value { color: #ffc107; }
        .stat-card.danger .stat-value { color: #ff4757; }
        .chart-container { height: 250px; position: relative; }
        .alerts-list { max-height: 300px; overflow-y: auto; }
        .alert-item { padding: 10px; border-bottom: 1px solid #2a2a4a; display: flex; justify-content: space-between; align-items: center; }
        .alert-item:last-child { border-bottom: none; }
        .alert-badge { padding: 4px 10px; border-radius: 15px; font-size: 0.8em; font-weight: bold; }
        .alert-badge.crash { background: #ff4757; }
        .alert-badge.warning { background: #ffc107; color: #000; }
        .alert-time { color: #666; font-size: 0.85em; }
        .refresh-btn { background: #00d4ff; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; color: #000; font-weight: bold; }
        .refresh-btn:hover { background: #00b8e6; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px; }
        h2 { color: #00d4ff; font-size: 1.1em; margin-bottom: 15px; }
        .status { display: flex; align-items: center; gap: 8px; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; }
        .status-dot.connected { background: #4caf50; animation: pulse 2s infinite; }
        .status-dot.disconnected { background: #ff4757; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        /* Device selector */
        .device-selector { display: flex; align-items: center; gap: 10px; }
        .device-select { padding: 8px 12px; border-radius: 5px; background: #0f0f1a; border: 1px solid #2a2a4a; color: #eee; font-size: 0.9em; cursor: pointer; }
        .device-select:focus { outline: none; border-color: #00d4ff; }
        .device-count { color: #888; font-size: 0.85em; }

        /* Score dial styles */
        .score-section { display: flex; justify-content: center; margin-bottom: 20px; }
        .score-card { background: #16213e; border-radius: 15px; padding: 30px; text-align: center; min-width: 300px; }
        .dial-container { position: relative; width: 200px; height: 120px; margin: 0 auto 15px; }
        .dial-svg { width: 100%; height: 100%; }
        .dial-bg { fill: none; stroke: #2a2a4a; stroke-width: 12; stroke-linecap: round; }
        .dial-fill { fill: none; stroke-width: 12; stroke-linecap: round; transition: stroke-dashoffset 0.5s ease, stroke 0.5s ease; }
        .score-value { position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); font-size: 3em; font-weight: bold; }
        .score-label { color: #888; font-size: 1.1em; margin-bottom: 10px; }
        .score-breakdown { display: flex; justify-content: center; gap: 20px; margin-top: 15px; font-size: 0.85em; color: #888; }
        .score-breakdown span { display: flex; align-items: center; gap: 5px; }
        .penalty-dot { width: 8px; height: 8px; border-radius: 50%; }
        .penalty-dot.crash { background: #ff4757; }
        .penalty-dot.warning { background: #ffc107; }
        .reset-btn { margin-top: 15px; background: transparent; border: 1px solid #ff4757; color: #ff4757; padding: 6px 16px; border-radius: 5px; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
        .reset-btn:hover { background: #ff4757; color: #fff; }

        /* Config panel styles */
        .config-panel { margin-bottom: 20px; }
        .config-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .config-header h2 { margin-bottom: 0; }
        .sync-status { font-size: 0.8em; color: #888; }
        .sync-status.synced { color: #4caf50; }
        .config-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; }
        .config-item { display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #1a1a2e; border-radius: 8px; }
        .config-item label { color: #ccc; font-size: 0.9em; }
        .config-controls { display: flex; align-items: center; gap: 10px; }
        .config-input { width: 70px; padding: 6px 10px; border: 1px solid #2a2a4a; border-radius: 5px; background: #0f0f1a; color: #eee; text-align: center; font-size: 1em; }
        .config-input:focus { outline: none; border-color: #00d4ff; }
        .config-input.synced { border-color: #4caf50; }
        .config-unit { color: #666; font-size: 0.85em; }
        .config-btn { background: #00d4ff; border: none; padding: 6px 12px; border-radius: 5px; cursor: pointer; color: #000; font-weight: bold; font-size: 0.85em; }
        .config-btn:hover { background: #00b8e6; }
        .config-btn:disabled { background: #444; cursor: not-allowed; }
        .config-btn.sending { background: #ffc107; }
        .config-btn.success { background: #4caf50; }
        .config-btn.error { background: #ff4757; }

        .device-id-display { font-family: monospace; color: #00d4ff; font-size: 0.85em; }

        /* Event history timeline */
        .history-card { margin-bottom: 20px; }
        .history-chart { height: 80px; position: relative; }
        .history-header { display: flex; justify-content: space-between; align-items: center; }
        .history-header h2 { margin-bottom: 0; }
        .history-legend { display: flex; gap: 15px; font-size: 0.8em; color: #888; }
        .history-legend span { display: flex; align-items: center; gap: 5px; }
        .legend-dot { width: 10px; height: 10px; border-radius: 2px; }
        .legend-dot.crash { background: #ff4757; }
        .legend-dot.warning { background: #ffc107; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Score weights: crashes count 5x more than warnings
        const CRASH_WEIGHT = 5;
        const WARNING_WEIGHT = 1;

        function calculateScore(batches, crashes, warnings) {
            if (batches === 0) return 100; // No data yet
            // Score = ratio of "good" batches to total weighted events
            // Each batch is a ~5s period of driving
            const weightedEvents = (crashes * CRASH_WEIGHT) + (warnings * WARNING_WEIGHT);
            if (weightedEvents === 0) return 100;
            // Score decreases as events per batch increases
            const eventsPerBatch = weightedEvents / batches;
            // Map to 0-100: 0 events/batch = 100, 1+ events/batch approaches 0
            const score = Math.round(100 * Math.exp(-eventsPerBatch * 2));
            return Math.max(0, Math.min(100, score));
        }

        function ScoreDial({ score, crashes, warnings, batches, onReset }) {
            const radius = 80;
            const circumference = Math.PI * radius;
            const scorePercent = Math.max(0, Math.min(100, score)) / 100;
            const offset = circumference * (1 - scorePercent);

            let color = '#4caf50';
            if (score < 50) color = '#ff4757';
            else if (score < 75) color = '#ffc107';

            const eventsPerBatch = batches > 0 ? ((crashes * CRASH_WEIGHT + warnings * WARNING_WEIGHT) / batches).toFixed(2) : '0.00';

            return (
                <div className="score-card">
                    <div className="score-label">Driving Score</div>
                    <div className="dial-container">
                        <svg className="dial-svg" viewBox="0 0 200 120">
                            <path className="dial-bg" d="M 20 100 A 80 80 0 0 1 180 100" />
                            <path className="dial-fill" d="M 20 100 A 80 80 0 0 1 180 100"
                                style={{ stroke: color, strokeDasharray: circumference, strokeDashoffset: offset }} />
                        </svg>
                        <div className="score-value" style={{ color }}>{score}</div>
                    </div>
                    <div className="score-breakdown">
                        <span><div className="penalty-dot crash"></div> {crashes} crashes</span>
                        <span><div className="penalty-dot warning"></div> {warnings} warnings</span>
                        <span style={{ color: '#666' }}>{eventsPerBatch} events/batch</span>
                    </div>
                    <button className="reset-btn" onClick={onReset}>Reset Score</button>
                </div>
            );
        }

        function ThresholdConfig({ type, label, deviceValue, onSend }) {
            const [value, setValue] = useState(deviceValue);
            const [status, setStatus] = useState('idle');
            const prevDeviceValue = useRef(deviceValue);

            useEffect(() => {
                if (deviceValue !== prevDeviceValue.current) {
                    setValue(deviceValue);
                    prevDeviceValue.current = deviceValue;
                }
            }, [deviceValue]);

            const sendThreshold = async () => {
                setStatus('sending');
                try {
                    const res = await onSend(type, parseFloat(value));
                    if (res.ok) {
                        setStatus('success');
                        setTimeout(() => setStatus('idle'), 2000);
                    } else {
                        setStatus('error');
                        setTimeout(() => setStatus('idle'), 2000);
                    }
                } catch (err) {
                    setStatus('error');
                    setTimeout(() => setStatus('idle'), 2000);
                }
            };

            const btnText = { idle: 'Set', sending: '...', success: 'OK', error: 'Err' };
            const isSynced = parseFloat(value) === deviceValue;

            return (
                <div className="config-item">
                    <label>{label}</label>
                    <div className="config-controls">
                        <input
                            type="number"
                            className={`config-input ${isSynced ? 'synced' : ''}`}
                            value={value}
                            onChange={(e) => setValue(e.target.value)}
                            min="0"
                            max="50"
                            step="0.5"
                        />
                        <span className="config-unit">G</span>
                        <button
                            className={`config-btn ${status}`}
                            onClick={sendThreshold}
                            disabled={status === 'sending' || isSynced}
                        >
                            {isSynced ? 'Synced' : btnText[status]}
                        </button>
                    </div>
                </div>
            );
        }

        function ConfigPanel({ deviceStatus, onSendThreshold }) {
            const { thresholds, lastUpdate, connected, id } = deviceStatus;

            const formatLastUpdate = () => {
                if (!lastUpdate) return 'Never';
                const seconds = Math.floor((Date.now() - lastUpdate) / 1000);
                if (seconds < 60) return `${seconds}s ago`;
                return `${Math.floor(seconds / 60)}m ago`;
            };

            return (
                <div className="card config-panel">
                    <div className="config-header">
                        <h2>Detection Thresholds {id && <span className="device-id-display">({id})</span>}</h2>
                        <span className={`sync-status ${connected ? 'synced' : ''}`}>
                            {connected ? `Synced ${formatLastUpdate()}` : 'Waiting for device...'}
                        </span>
                    </div>
                    <div className="config-grid">
                        <ThresholdConfig type="crash" label="Crash Detection" deviceValue={thresholds.crash} onSend={onSendThreshold} />
                        <ThresholdConfig type="braking" label="Harsh Braking" deviceValue={thresholds.braking} onSend={onSendThreshold} />
                        <ThresholdConfig type="accel" label="Harsh Acceleration" deviceValue={thresholds.accel} onSend={onSendThreshold} />
                        <ThresholdConfig type="cornering" label="Harsh Cornering" deviceValue={thresholds.cornering} onSend={onSendThreshold} />
                    </div>
                </div>
            );
        }

        function DeviceSelector({ devices, selectedDevice, onSelect }) {
            return (
                <div className="device-selector">
                    <select className="device-select" value={selectedDevice || ''} onChange={(e) => onSelect(e.target.value || null)}>
                        <option value="">All Devices</option>
                        {devices.map(d => (
                            <option key={d.id} value={d.id}>{d.id}</option>
                        ))}
                    </select>
                    <span className="device-count">{devices.length} device{devices.length !== 1 ? 's' : ''}</span>
                </div>
            );
        }

        function EventHistory({ history }) {
            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            useEffect(() => {
                if (!chartRef.current) return;

                // Build hourly buckets for last 24 hours
                const now = new Date();
                const hours = [];
                for (let i = 23; i >= 0; i--) {
                    const d = new Date(now.getTime() - i * 60 * 60 * 1000);
                    d.setMinutes(0, 0, 0);
                    hours.push(d.toISOString().slice(0, 13).replace('T', ' ') + ':00');
                }

                // Map history data to hourly buckets
                const crashData = hours.map(h => {
                    const match = history.find(e => e.hour === h && e.type === 'crash');
                    return match ? match.count : 0;
                });
                const warningData = hours.map(h => {
                    const match = history.find(e => e.hour === h && e.type === 'warning');
                    return match ? match.count : 0;
                });

                const labels = hours.map(h => h.slice(11, 16)); // Just HH:MM

                const ctx = chartRef.current.getContext('2d');

                if (chartInstance.current) {
                    chartInstance.current.data.labels = labels;
                    chartInstance.current.data.datasets[0].data = crashData;
                    chartInstance.current.data.datasets[1].data = warningData;
                    chartInstance.current.update('none');
                } else {
                    chartInstance.current = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels,
                            datasets: [
                                { label: 'Crashes', data: crashData, backgroundColor: '#ff4757', borderRadius: 2 },
                                { label: 'Warnings', data: warningData, backgroundColor: '#ffc107', borderRadius: 2 }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            animation: false,
                            scales: {
                                x: {
                                    stacked: true,
                                    grid: { display: false },
                                    ticks: { color: '#666', maxRotation: 0, autoSkip: true, maxTicksLimit: 12 }
                                },
                                y: {
                                    stacked: true,
                                    display: false,
                                    beginAtZero: true
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        title: (items) => `Hour: ${items[0].label}`
                                    }
                                }
                            }
                        }
                    });
                }
            }, [history]);

            return (
                <div className="card history-card">
                    <div className="history-header">
                        <h2>Event History (24h)</h2>
                        <div className="history-legend">
                            <span><div className="legend-dot crash"></div> Crashes</span>
                            <span><div className="legend-dot warning"></div> Warnings</span>
                        </div>
                    </div>
                    <div className="history-chart">
                        <canvas ref={chartRef}></canvas>
                    </div>
                </div>
            );
        }

        // Debounce alerts: group same event types within a time window
        const ALERT_DEBOUNCE_MS = 5000; // 5 second window

        function dedupeAlerts(alerts) {
            if (!alerts || alerts.length === 0) return [];

            const result = [];
            let prev = null;

            for (const alert of alerts) {
                const eventKey = `${alert.type}-${alert.event || ''}`;
                const timestamp = new Date(alert.received_at).getTime();

                if (prev && prev.key === eventKey) {
                    const timeDiff = prev.timestamp - timestamp; // alerts are sorted desc
                    if (timeDiff < ALERT_DEBOUNCE_MS) {
                        // Same event within debounce window - increment count
                        prev.count++;
                        continue;
                    }
                }

                // New distinct event
                const newEntry = { ...alert, count: 1, key: eventKey, timestamp };
                result.push(newEntry);
                prev = newEntry;
            }

            return result;
        }

        function App() {
            const [devices, setDevices] = useState([]);
            const [selectedDevice, setSelectedDevice] = useState(null);
            const [stats, setStats] = useState({ totalAlerts: 0, crashes: 0, warnings: 0, totalReadings: 0, totalBatches: 0 });
            const [alerts, setAlerts] = useState([]);
            const [readings, setReadings] = useState([]);
            const [history, setHistory] = useState([]);
            const [deviceStatus, setDeviceStatus] = useState({
                id: null,
                connected: false,
                thresholds: { crash: 3.0, braking: 2.0, accel: 1.5, cornering: 2.0 },
                lastUpdate: null
            });
            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            const score = calculateScore(stats.totalBatches, stats.crashes, stats.warnings);

            const resetScore = async () => {
                if (!confirm('Reset driving score? This will clear all alerts.')) return;
                const deviceParam = selectedDevice ? `?device=${selectedDevice}` : '';
                await fetch(`/api/score/reset${deviceParam}`, { method: 'POST' });
                fetchData();
            };

            const fetchData = async () => {
                try {
                    const deviceParam = selectedDevice ? `?device=${selectedDevice}` : '';
                    const deviceParamAmp = selectedDevice ? `&device=${selectedDevice}` : '';

                    const [devicesRes, statsRes, alertsRes, readingsRes, historyRes] = await Promise.all([
                        fetch('/api/devices'),
                        fetch(`/api/stats${deviceParam}`),
                        fetch(`/api/alerts?limit=20${deviceParamAmp}`),
                        fetch(`/api/readings/latest?limit=30000${deviceParamAmp}`),
                        fetch(`/api/alerts/history${deviceParam}`)
                    ]);

                    const devicesData = await devicesRes.json();
                    setDevices(devicesData);
                    setStats(await statsRes.json());
                    setAlerts(await alertsRes.json());
                    setReadings(await readingsRes.json());
                    setHistory(await historyRes.json());

                    // Fetch device-specific status if a device is selected
                    if (selectedDevice) {
                        const statusRes = await fetch(`/api/devices/${selectedDevice}/status`);
                        if (statusRes.ok) {
                            setDeviceStatus(await statusRes.json());
                        }
                    } else if (devicesData.length > 0) {
                        // Show first device status when viewing all
                        const statusRes = await fetch(`/api/devices/${devicesData[0].id}/status`);
                        if (statusRes.ok) {
                            setDeviceStatus(await statusRes.json());
                        }
                    } else {
                        setDeviceStatus({
                            id: null,
                            connected: false,
                            thresholds: { crash: 11.0, braking: 9.0, accel: 7.0, cornering: 8.0 },
                            lastUpdate: null
                        });
                    }
                } catch (err) {
                    console.error('Fetch error:', err);
                }
            };

            const sendThreshold = async (type, value) => {
                const deviceId = selectedDevice || (devices.length > 0 ? devices[0].id : null);
                if (!deviceId) {
                    return { ok: false };
                }
                return fetch(`/api/devices/${deviceId}/threshold`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type, value })
                });
            };

            useEffect(() => {
                fetchData();
                const interval = setInterval(fetchData, 3000);
                return () => clearInterval(interval);
            }, [selectedDevice]);

            useEffect(() => {
                if (!chartRef.current || readings.length === 0) return;

                const ctx = chartRef.current.getContext('2d');
                const labels = readings.map((_, i) => i);
                const dataX = readings.map(r => r.x);
                const dataY = readings.map(r => r.y);
                const dataZ = readings.map(r => r.z);

                if (chartInstance.current) {
                    chartInstance.current.data.labels = labels;
                    chartInstance.current.data.datasets[0].data = dataX;
                    chartInstance.current.data.datasets[1].data = dataY;
                    chartInstance.current.data.datasets[2].data = dataZ;
                    chartInstance.current.update('none');
                } else {
                    chartInstance.current = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels,
                            datasets: [
                                { label: 'X', data: dataX, borderColor: '#ff6384', borderWidth: 1, pointRadius: 0 },
                                { label: 'Y', data: dataY, borderColor: '#36a2eb', borderWidth: 1, pointRadius: 0 },
                                { label: 'Z', data: dataZ, borderColor: '#4bc0c0', borderWidth: 1, pointRadius: 0 }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            animation: false,
                            scales: {
                                x: { display: false },
                                y: { grid: { color: '#2a2a4a' }, ticks: { color: '#888' } }
                            },
                            plugins: { legend: { labels: { color: '#eee' } } }
                        }
                    });
                }
            }, [readings]);

            const formatTime = (timestamp) => {
                if (!timestamp) return 'N/A';
                return new Date(timestamp).toLocaleString();
            };

            return (
                <div className="container">
                    <div className="header">
                        <h1>Driving Safety Monitor</h1>
                        <DeviceSelector devices={devices} selectedDevice={selectedDevice} onSelect={setSelectedDevice} />
                        <div className="status">
                            <div className={`status-dot ${deviceStatus.connected ? 'connected' : 'disconnected'}`}></div>
                            <span>{deviceStatus.connected ? 'Online' : 'Offline'}</span>
                            <button className="refresh-btn" onClick={fetchData}>Refresh</button>
                        </div>
                    </div>

                    <div className="score-section">
                        <ScoreDial
                            score={score}
                            crashes={stats.crashes}
                            warnings={stats.warnings}
                            batches={stats.totalBatches}
                            onReset={resetScore}
                        />
                    </div>

                    <EventHistory history={history} />

                    <ConfigPanel deviceStatus={deviceStatus} onSendThreshold={sendThreshold} />

                    <div className="grid">
                        <div className="card stat-card">
                            <div className="stat-value">{stats.totalBatches}</div>
                            <div className="stat-label">Total Batches</div>
                        </div>
                        <div className="card stat-card">
                            <div className="stat-value">{(stats.totalReadings / 1000).toFixed(1)}k</div>
                            <div className="stat-label">Sensor Readings</div>
                        </div>
                        <div className="card stat-card warning">
                            <div className="stat-value">{stats.warnings}</div>
                            <div className="stat-label">Warnings</div>
                        </div>
                        <div className="card stat-card danger">
                            <div className="stat-value">{stats.crashes}</div>
                            <div className="stat-label">Crashes</div>
                        </div>
                    </div>

                    <div className="grid" style={{ gridTemplateColumns: '2fr 1fr' }}>
                        <div className="card">
                            <h2>Accelerometer Data (Last 5 minutes)</h2>
                            <div className="chart-container">
                                <canvas ref={chartRef}></canvas>
                            </div>
                        </div>
                        <div className="card">
                            <h2>Recent Alerts</h2>
                            <div className="alerts-list">
                                {alerts.length === 0 ? (
                                    <p style={{ color: '#666', padding: '20px', textAlign: 'center' }}>No alerts yet</p>
                                ) : (
                                    dedupeAlerts(alerts).map(alert => (
                                        <div key={alert.id} className="alert-item">
                                            <div>
                                                <span className={`alert-badge ${alert.type}`}>
                                                    {alert.type === 'crash' ? 'CRASH' : alert.event?.replace('_', ' ').toUpperCase()}
                                                </span>
                                                {alert.count > 1 && <span style={{ marginLeft: 8, color: '#888', fontSize: '0.85em' }}>Ã—{alert.count}</span>}
                                                {alert.type === 'crash' && <span style={{ marginLeft: 10 }}>mag: {alert.accel_magnitude?.toFixed(2)}</span>}
                                                {alert.type === 'warning' && <span style={{ marginLeft: 10 }}>y: {alert.accel_y?.toFixed(2)}</span>}
                                            </div>
                                            <div className="alert-time">{formatTime(alert.received_at)}</div>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
